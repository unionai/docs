---
title: ImageSpec
weight: 7
variants: +flyte +serverless +byoc +selfmanaged
---

# ImageSpec

When deploying a task, {{< key product_name >}} needs to know how to build the container image that will be used to run that task.
You specify this information in an `ImageSpec` object that is passed to the `@{{< key kit_as >}}.task` decorator.

Here is a simple example:

{{< variant flyte >}}
{{< markdown >}}

```python
import {{< key kit_import >}}

image_spec = union.ImageSpec(
    builder="default",
    name="say-hello-image",
    requirements="uv.lock",
    registry=registry=os.environ.get("IMAGE_REGISTRY", None),
)

@{{< key kit_as >}}.task(container_image=image_spec)
def say_hello(name: str) -> str:
    return f"Hello, {name}!"

@{{< key kit_as >}}.workflow
def hello_world_wf(name: str = "world") -> str:
    greeting = say_hello(name=name)
    return greeting
```

{{< /markdown >}}
{{< /variant >}}
{{< variant serverless byoc selfmanaged >}}
{{< markdown >}}

```python
import {{< key kit_import >}}

image_spec = union.ImageSpec(
    builder="union",
    name="say-hello-image",
    requirements="uv.lock",
)

@{{< key kit_as >}}.task(container_image=image_spec)
def say_hello(name: str) -> str:
    return f"Hello, {name}!"

@{{< key kit_as >}}.workflow
def hello_world_wf(name: str = "world") -> str:
    greeting = say_hello(name=name)
    return greeting
```

{{< /markdown >}}
{{< /variant >}}

Here, the `ImageSpec` class is used to specify the container image to be used for the `say_hello` task:

{{< variant flyte >}}
{{< markdown >}}

* The `builder` parameter specifies how the image should be built.
  * In this case we specify `default`. This will build the image using `docker` on your local machine.
    See [Local image builder](#local-image-builder) below for more details.

> [!NOTE]
> Omitting the `builder` parameter is equivalent to specifying `builder="default"`.

{{< /markdown >}}
{{< /variant >}}
{{< variant serverless byoc selfmanaged >}}
{{< markdown >}}

* The `builder` parameter specifies how the image should be built.
  * In this case we specify `union`, meaning that the image will be built in the cloud using {{< key product_name >}}'s built-in cloud image builder.
    See [Cloud image builder](#cloud-image-builder) below for more details.
  * Alternatively, you can specify `default`. This will build the image using `docker` on your local machine.
    See [Local image builder](#local-image-builder) below for more details.

> [!NOTE]
> In {{< key product_name >}} Serverless, omitting the `builder` parameter is equivalent to specifying `builder="union"`.
> In {{< key product_name >}} BYOC and Self-managed, omitting the `builder` parameter is equivalent to specifying `builder="default"`
> (this differentiation exists for purposes of backward compatibility).

{{< /markdown >}}
{{< /variant >}}

* The `name` parameter specifies the name of the image. This name will be used to identify the image in the container registry.

* The `requirements` parameter specifies the path to a file (relative to the directory in which the `{{< key cli >}} run` or `{{< key cli >}} register` command is invoked) that specifies the dependencies to be installed in the image.
  The file may be:
  * A `requirements.txt` file.
  * A `uv.lock` file generated by the `uv sync` command.
  * A `poetry.lock` file generated by the `poetry install` command.
  * A `pyproject.toml` file.

When you execute the `{{< key cli >}} run` or `{{< key cli >}} register` command, {{< key product_name >}} will build the container image defined in `ImageSpec` block
(as well as registering the tasks and workflows defined in your code).

{{< variant serverless byoc selfmanaged >}}
{{< markdown >}}

## Cloud image builder

{{< key product_name >}} Serverless will build the image using its `ImageBuilder` service in the cloud
and registered the image in {{< key product_name >}}'s own container registry.
From there it will be pulled and installed in the task container when it spins up.
All this is done transparently and does not require any set up by the user.

> [!NOTE] Local image build in BYOC
> In {{< key product_name >}} Serverless images defined by `ImageSpec` are always built using the {{< key product_name >}} cloud image builder.
> In {{< key product_name >}} BYOC, you can optionally build images from the `ImageSpec` on your local machine by specifying `builder="envd"` in the `ImageSpec`.
> See [Local image builder](#local-image-builder) in the BYOC documentation for more details.

## {{< key product_name >}} cloud image builder

If you have specified `builder="union"` in the `ImageSpec`, {{< key product_name >}} will build the image using its `ImageBuilder` service in the cloud
and registered the image in {{< key product_name >}}'s own container registry. From there it will be pulled and installed in the task container when it spins up.
All this is done transparently and does not require any set up by the user.

{{< /markdown >}}
{{< /variant >}}

## Local image builder

<!-- TODO: DONE TO HERE -->

If you have not specified a `builder` or have specified `builder="envd"`, {{< key product_name >}} will build the image locally on your machine and push it to the registry you specify.
This also requires that you specify a `registry` parameter in the `ImageSpec`.
For example:

```python
image_spec = union.ImageSpec(
builder="envd",
name="say-hello-image",
requirements="uv.lock",
registry="https://ghcr.io/<my-github-org>",
)
```

Here we assume you are using GitHub's GHCR, and that you substitute your GitHub organization name for `<my-github-org>`.

### Local container engine

To enable local image building you must have an [OCI-compatible](https://opencontainers.org/) container engine, like [Docker](https://docs.docker.com/get-docker/), installed and running locally.
Other options include [Podman](https://podman.io/), [LXD](https://linuxcontainers.org/lxd/introduction/), or [Containerd](https://containerd.io/).

### Access to a container registry

You will also need access to a container registry.
You must specify the URL of the registry in the `registry` parameter of the `ImageSpec`.

Above we used the GitHub Container Registry (GHCR) that comes as part of your GitHub account.
For more information, see [Working with the Container registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry).

You may use another container registry if you prefer,
such as [Docker Hub](https://hub.docker.com/),
[Amazon Elastic Container Registry (ECR)](../integrations/enabling-aws-resources/enabling-aws-ecr),
or [Google Artifact Registry (GAR)](../integrations/enabling-gcp-resources/enabling-google-artifact-registry).

You will need to set up your local Docker client to authenticate to GHCR in order for `{{< key cli >}}` to be able to push the image built according to the `ImageSpec` to GHCR.

Follow the directions in [Working with the Container registry > Authenticating to the Container registry](https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-container-registry#authenticating-to-the-container-registry).

### Make your image accessible to {{< key product_name >}}

In addition to making sure your registry is accessible from your local machine, you will need to ensure that the specific image, once pushed to the registry, is itself publicly accessible.

> [!NOTE] Make your image public
> Note that in the case of our example registry (GHCR), making the image public can only be done once the image _has been_ pushed.
> This means that you will need to register your workflow first, then make the image public and then run the workflow from the {{< key product_name >}} UI.
> If you try to run the workflow before making the image public (for example by doing a `{{< key cli >}} run` which both registers and runs immediately)
> the workflow execution will fail with an `ImagePullBackOff `error.

In the GitHub Container Registry, switch the visibility of your container image to Public. For more information, see [Configuring a package's access control and visibility](https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility#about-inheritance-of-access-permissions-and-visibility).

At this point, you can run the workflow from the {{< key product_name >}} interface.

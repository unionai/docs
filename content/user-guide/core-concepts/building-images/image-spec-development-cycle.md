---
title: ImageSpec
weight: 1
variants: +flyte +serverless +byoc +selfmanaged
---

# ImageSpec

When deploying a task, {{< key product_name >}} needs to know how to build the container image that will be used to run that task.
You specify this information in an `ImageSpec` object that is passed to the `@{{< key kit_as >}}.task` decorator.

Here is a simple example:

{{< variant flyte >}}
{{< markdown >}}

```python
import {{< key kit_import >}}

image_spec = union.ImageSpec(
    builder="default",
    registry=registry=os.environ.get("IMAGE_REGISTRY", None),
    name="say-hello-image",
    requirements="uv.lock",
)

@{{< key kit_as >}}.task(container_image=image_spec)
def say_hello(name: str) -> str:
    return f"Hello, {name}!"

@{{< key kit_as >}}.workflow
def hello_world_wf(name: str = "world") -> str:
    greeting = say_hello(name=name)
    return greeting
```

{{< /markdown >}}
{{< /variant >}}
{{< variant serverless byoc selfmanaged >}}
{{< markdown >}}

```python
import {{< key kit_import >}}

image_spec = union.ImageSpec(
    builder="union",
    name="say-hello-image",
    requirements="uv.lock",
)

@{{< key kit_as >}}.task(container_image=image_spec)
def say_hello(name: str) -> str:
    return f"Hello, {name}!"

@{{< key kit_as >}}.workflow
def hello_world_wf(name: str = "world") -> str:
    greeting = say_hello(name=name)
    return greeting
```

{{< /markdown >}}
{{< /variant >}}

Here, the `ImageSpec` class is used to specify the container image to be used for the `say_hello` task.
ImageSpec supports [a large set of configuration parameters](../../api-reference/flytekit-sdk/packages/flytekit.image_spec.image_spec.md), here we show a few basic ones:

{{< variant flyte >}}
{{< markdown >}}

* `builder`: Specifies how the image is built.
  * In this case we specify `default`.
    This will [build the image on your local machine](./local-image-builder).

  > [!NOTE]
  > In Flyte OSS, omitting the `builder` parameter is equivalent to specifying `builder="default"`.

* `registry` Specifies the container registry to which the image will be pushed after it is built.
  * In this case we use an environment variable to hold the URL of the registry.
  * This is the registry to which the image will be pushed once it is built, and from which it will be pulled when the task using that image is instantiated.
  * See [Local image builder > Container registry](./local-image-builder#container-registry).

{{< /markdown >}}
{{< /variant >}}
{{< variant serverless byoc selfmanaged >}}
{{< markdown >}}

* `builder`: Specifies how the image is built.
  * In this case we specify `union`.
    This will build the image using {{< key product_name >}}'s built-in [Cloud image builder](./cloud-image-builder).
  * Alternatively, you can specify `default`.
    This will [build the image on your local machine](./local-image-builder).
    This will also require adding a [`registry` parameter](./local-image-builder#container-registry).

  > [!NOTE]
  > In {{< key product_name >}} Serverless, omitting the `builder` parameter is equivalent to specifying `builder="union"`.
  > In {{< key product_name >}} BYOC and Self-managed, omitting the `builder` parameter is equivalent to specifying `builder="default"`
  > (this differentiation exists for purposes of backward compatibility).

{{< /markdown >}}
{{< /variant >}}

* The `name` parameter specifies the name of the image. This name will be used to identify the image in the container registry.

* The `requirements` parameter specifies the path to a file (relative to the directory in which the
  `{{< key cli >}} run` or `{{< key cli >}} register` command is invoked) that specifies the dependencies to be installed in the image.
  The file may be:
  * A `requirements.txt` file.
  * A `uv.lock` file generated by the `uv sync` command.
  * A `poetry.lock` file generated by the `poetry install` command.
  * A `pyproject.toml` file.

When you execute the `{{< key cli >}} run` or `{{< key cli >}} register` command, {{< key product_name >}} will build the container image defined in `ImageSpec` block
(as well as registering the tasks and workflows defined in your code).
